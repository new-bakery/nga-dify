import json
import base64
import requests
from typing import Any
from decimal import Decimal
from datetime import datetime, date
from uuid import UUID
from sqlalchemy import create_engine
from sqlalchemy.engine import Engine
from sqlalchemy.sql import text as sql_text

from core.tools.entities.tool_entities import ToolInvokeMessage
from core.tools.tool.builtin_tool import BuiltinTool

from core.tools.provider.builtin.newbakery.config_keys import *
from core.tools.provider.builtin.newbakery.tools.newbakery_tool import *

PONDSQL = 'pondsql://'

class SQLRunnerTool(BuiltinTool):
    def _run_sql(self, connection_string : str, sql: str, max_rows: int = 500):
        res = {IS_ERROR: False, ERROR_MESSAGE:'', "sql": sql }
        try:
            results = []
            engine: Engine = create_engine(connection_string, echo=False)
            with engine.connect() as connection:
                sql = sql_text(sql)
                cur = connection.execute(sql)
                columns = cur.keys()
                data = cur.fetchmany(max_rows)
                for row in data:
                    results.append(dict(zip(columns, row)))
                normalized_data = [
                    {
                        key.strip('"'): (
                            str(value) if isinstance(value, UUID)  # Convert UUID to string
                            else base64.b64encode(value).decode('utf-8') if isinstance(value, bytes)  # Convert bytes to Base64
                            else value.isoformat() if isinstance(value, (datetime, date))  # Convert datetime to ISO format string
                            else float(value) if isinstance(value, Decimal)  # Convert Decimal to float
                            else list(value) if isinstance(value, set)  # Convert set to list
                            else value  # Keep other types as is
                        )
                        for key, value in row.items()
                    }
                    for row in results
                ]
                res[RESULTS] = normalized_data
        except Exception as e:
            res[IS_ERROR] = True
            res[ERROR_MESSAGE] = str(e)
        message = self.create_json_message(res)
        return message
    
    def _run_pondsql(self, connection_string : str, sql: str, max_rows: int = 500):
        res = {IS_ERROR: False, ERROR_MESSAGE:'', "sql": sql }
        try:
            database = connection_string[len(PONDSQL):]
            endpoint = self.runtime.credentials[PONDSQL_CONNECTION_STRING]
            endpoint = endpoint.rstrip('/') + '/query' if not endpoint.endswith("query") else endpoint
            payload = {
                "source_doc_id": database,
                "query": sql
            }
            response = requests.post(endpoint, json=payload)
            if response.status_code == 200:
                res[RESULTS] = response.json()
            else:
                raise Exception(f'{response.status_code}, {response.text}')
        except Exception as e:
            res[IS_ERROR] = True
            res[ERROR_MESSAGE] = str(e)
        message = self.create_json_message(res)
        return message

    def _invoke(self, user_id: str, tool_parameters: dict[str, Any]) -> ToolInvokeMessage:
        connection_string = tool_parameters.get("sql_connection_string", "")
        sql = tool_parameters.get("sql", "")
        max_rows = int(tool_parameters.get("max_rows", 500))
       
        try:
            sql = json.loads(sql)['answer']  # The sql might be a json, generated by LLM, using JSON format result in Dify
        except:
            pass
        if connection_string.startswith(PONDSQL):
            return self._run_pondsql(connection_string, sql, max_rows)
        else:
            return self._run_sql(connection_string, sql, max_rows)
        

    
